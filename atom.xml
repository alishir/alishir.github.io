<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alishir.github.io/</id>
    <title>نُکَتْ Blog</title>
    <updated>2025-09-06T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alishir.github.io/"/>
    <subtitle>نُکَتْ Blog</subtitle>
    <icon>https://alishir.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[الیکسیر برای پروژه‌های مخابراتی]]></title>
        <id>https://alishir.github.io/why-we-chose-elixir-for-telecom-projects</id>
        <link href="https://alishir.github.io/why-we-chose-elixir-for-telecom-projects"/>
        <updated>2025-09-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[از جمله مهم‌ترین الزامات زیرساخت‌های مخابراتی، حفظ عملکرد سیستم در]]></summary>
        <content type="html"><![CDATA[<p>از جمله مهم‌ترین الزامات زیرساخت‌های مخابراتی، حفظ عملکرد سیستم در
مواجهه با خطاها است. زبان ارلنگ در پاسخ به این نیاز طراحی شده است.</p>
<p>الیکسیر یک زبان برنامه‌نویسی همروند و تابعی، و مبتنی بر ماشین مجازی
BEAM است. ماشین مجازی BEAM در خلال توسعه و بهبود زبان برنامه‌نویسی
ارلنگ ایجاد شده است.</p>
<p>به عنوان مثال یک سرور ثبت‌کننده<sup><a href="https://alishir.github.io/why-we-chose-elixir-for-telecom-projects#user-content-fn-1-5297b1" id="user-content-fnref-1-5297b1" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup> را در نظر بگیرد. این سرور وظیفه
دارد با پردازش پیام‌های SIP، نگاشت بین نام کاربری مشترک و نقطه اتصال او
در شبکه را نگهداری کند. به عنوان نمونه این سرور میداند که کاربر با نام
کاربری <a href="mailto:bob@example.com" target="_blank" rel="noopener noreferrer">bob@example.com</a> در آدرس 172.16.20.110:5060 در دسترس است. با
توجه به تنوع نرم‌افزارهایی که کاربر می‌تواند برای این منظور استفاده کند،
سرور ثبت‌کننده باید دقت کافی در پردازش پیام‌های دریافتی را لحاظ کند و با
<a href="https://en.wikipedia.org/wiki/Defensive_programming" target="_blank" rel="noopener noreferrer">رویکرد تدافعی</a>
انواع خطاهای احتمالی را بررسی کند. اما با تمام این ملاحظات باز هم ممکن
است یک پیام ارسالی از طرف کاربر باعث ایجاد اختلال در عملکرد کل سرور
شود.  برای نمونه می‌توان به <a href="https://skalatan.de/en/blog/advisory-hw-2018-05" target="_blank" rel="noopener noreferrer">این
CVE</a> در kamailio
اشاره کرد که یک پیام با ساختار نامناسب ‌می‌توانسته عملکرد کل سرور را
مختل کند.</p>
<p>زبان ارلنگ با الهام از مفهوم پردازه‌ها<sup><a href="https://alishir.github.io/why-we-chose-elixir-for-telecom-projects#user-content-fn-2-5297b1" id="user-content-fnref-2-5297b1" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup> در سیستم عامل و فراهم کردن
زیرساخت مناسب برای شکستن کارهای پیچیده به سلسله مراتبی از کارهای
ساده‌تر، بستر مناسبی برای توسعه نرم‌افزارهای پایدار در برابر خطاها ایجاد
کرده است.</p>
<p>همان‌طور که پردازه‌ها در سیستم عامل به صورت کاملا مجزا از یکدیگر اجرا
می‌شوند و اختلال در یک پردازه تاثیری در عملکرد دیگر پردازه‌ها ندارد، در
زبان ارلنگ نیز پردازه‌ها کاملا مستقل از یکدیگر اجرا می‌شوند. البته
قابلیت‌های
<a href="https://www.erlang.org/doc/system/ref_man_processes.html#links" target="_blank" rel="noopener noreferrer">link</a>
و
<a href="https://www.erlang.org/doc/system/ref_man_processes.html#monitors" target="_blank" rel="noopener noreferrer">monitor</a>
کردن پردازه‌ها در ارلنگ وجود دارد. با استفاده از این قابلیت‌ها یک پردازه
می‌تواند در جریان وضعیت پردازه دیگر قرار بگیرد و در صورت بروز مشکل،
رویه‌های لازم را اجرا کند. این دو مفهوم پایه و اساس بحث درخت نظارت<sup><a href="https://alishir.github.io/why-we-chose-elixir-for-telecom-projects#user-content-fn-3-5297b1" id="user-content-fnref-3-5297b1" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup>
در ارلنگ است که خود نیاز به مطلبی مجزا دارد.</p>
<p>تفاوت اساسی پردازه‌های ارلنگ با پردازه‌های سیستم عامل، هزینه و سربار
بسیار پائین ایجاد و نگهداری آن‌هاست. به گونه‌ای که می‌توان در مدت زمان
اندکی میلیون‌ها پردازه ایجاد کرد و آن‌ها به صورت همروند در حال اجرا
باشند. این تفاوت اساسی امکان توسعه سیستم‌های پایدار در برابر خطا را
فراهم می‌کند.</p>
<p>در مثال سرور ثبت‌کننده که پیش‌تر بیان شد، اگر هر پیام دریافتی توسط یک
پردازه مستقل پردازش شود، در صورت بروز خطا تنها عملکرد آن پردازه مختل
می‌شود و عملکرد کلی سیستم دچار مشکل نمی‌شود. به این ترتیب با استفاده از
مفهوم پردازه‌ها می‌توان دامنه انتشار خطا را به شدت محدود کرد و عملکرد
سیستم در مواجهه با خطاهای مختلف را حفظ کرد. از آنجایی که در سیستم‌های
مخابراتی عمدتا تعامل بین سیستم‌های متنوع از شرکت‌های مختلف وجود دارد و
هر شرکت می‌تواند پیاده‌سازی متفاوتی از استاندارد داشته باشد، کاهش دامنه
خطا امری حیاتی و ضروری است. این
<a href="https://youtu.be/HyiSYHfESX4?t=1238" target="_blank" rel="noopener noreferrer">ویدئو</a> به نقش این ویژگی اساسی در
توسعه محصول SGSN/MME شرکت اریکسون و دستیابی به <a href="https://en.wikipedia.org/wiki/Five_nines#:~:text=Five%20nines%2C%20commonly%20taken%20to,minutes%20of%20downtime%20per%20year" target="_blank" rel="noopener noreferrer">دسترسی‌پذیری
۹۹.۹۹۹٪</a>
اشاره می‌کند.</p>
<!-- -->
<section data-footnotes="true" class="footnotes"><h2 class="anchor anchorWithStickyNavbar_tMk3 sr-only" id="footnote-label">پاورقی‌ها<a href="https://alishir.github.io/why-we-chose-elixir-for-telecom-projects#footnote-label" class="hash-link" aria-label="لینک مستقیم به پاورقی‌ها" title="لینک مستقیم به پاورقی‌ها">​</a></h2>
<ol>
<li id="user-content-fn-1-5297b1">
<p>Registrar Server <a href="https://alishir.github.io/why-we-chose-elixir-for-telecom-projects#user-content-fnref-1-5297b1" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-2-5297b1">
<p>Process <a href="https://alishir.github.io/why-we-chose-elixir-for-telecom-projects#user-content-fnref-2-5297b1" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-3-5297b1">
<p>Supervision Tree <a href="https://alishir.github.io/why-we-chose-elixir-for-telecom-projects#user-content-fnref-3-5297b1" data-footnote-backref="" aria-label="Back to reference 3" class="data-footnote-backref">↩</a></p>
</li>
</ol>
</section>]]></content>
        <author>
            <name>علی</name>
            <uri>https://www.linkedin.com/in/ali-shirvani-37a031191/</uri>
        </author>
        <category label="Elixir" term="Elixir"/>
        <category label="Erlang" term="Erlang"/>
        <category label="BEAM" term="BEAM"/>
        <category label="Telecom" term="Telecom"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[آشنایی با استاندارد AML]]></title>
        <id>https://alishir.github.io/advanced-mobile-location</id>
        <link href="https://alishir.github.io/advanced-mobile-location"/>
        <updated>2025-04-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[تعیین سریع و دقیق موقعیت تماس‌گیرنده با خدمات اضطراری مانند اورژانس،]]></summary>
        <content type="html"><![CDATA[<p>تعیین سریع و دقیق موقعیت تماس‌گیرنده با خدمات اضطراری مانند اورژانس،
مسأله‌ای حیاتی است که می‌تواند مرز بین مرگ و زندگی را مشخص کند. در شرایط
بحرانی، هر ثانیه اهمیت دارد، اما به‌دلیل وضعیت روحی یا جسمی نامناسب،
بسیاری از افراد قادر به اعلام دقیق موقعیت خود نیستند و همین مسئله باعث
تأخیر در رسیدن نیروهای امدادی می‌شود.  با گسترش چشم‌گیر تلفن‌های همراه،
بخش زیادی از تماس‌های اضطراری از طریق این دستگاه‌ها انجام می‌شود. این
روند، چالشی جدی در ارائه خدمات مؤثر اضطراری به‌وجود آورده است. در چنین
شرایطی، ارسال خودکار، سریع و دقیق موقعیت مکانی می‌تواند نقشی تعیین‌کننده
در نجات جان افراد داشته باشد.</p>
<p>طبق گزارش کمیسیون ارتباطات ایالات متحده کاهش زمان پاسخ‌گویی در موارد
اضطراری به مدت یک دقیقه میتواند باعث نجات جان ده هزار نفر تنها در
آمریکا شود. این <a href="https://www.youtube.com/watch?v=T0sJ6CZfAh8" target="_blank" rel="noopener noreferrer">ویدئو</a>،
که بر اساس یک داستان واقعی ساخته شده، به خوبی نقش حیاتی این سیستم در
نجات فردی سانحه دیده در کوهستانی برفی را نشان می‌دهد. به خاطر استفاده
از سرویس اعلام خودکار موقعیت فرد حادثه دیده، حتی با توجه به عدم
آنتن‌دهی مناسب و عدم امکان برقراری تماس صوتی، امدادگران با دقت ۶ متر به
موقعیت فرد سانحه دیده دسترسی پیدا می‌کنند. در صورت عدم استفاده از چنین
سرویسی باید فضایی به وسعت چندین کیلومتر مربع را جست‌وجو می‌کردند.</p>
<p>با اینکه استانداردهای تعیین موقعیت مکانی مشترکین در شبکه‌های تلفن همراه
از حدود دو دهه پیش تدوین شده بود، اما به‌دلیل پیچیدگی، هزینه بالا و دقت
ناکافی، این روش‌ها به‌طور گسترده مورد استفاده قرار نگرفتند.  در سال‌های
۲۰۱۴ و ۲۰۱۵، انگلستان با همکاری شرکت‌های HTC و Sony پروژه‌ای آزمایشی
برای افزایش دقت و سرعت خدمات اضطراری اجرا کرد. در این پروژه، موقعیت
مکانی کاربران که از طریق GPS یا WiFi محاسبه می‌شد، به‌صورت خودکار برای
مراکز امداد ارسال می‌گردید. نتایج موفق این طرح منجر به انتشار<a href="https://www.etsi.org/deliver/etsi_tr/103300_103399/103393/01.01.01_60/tr_103393v010101p.pdf" target="_blank" rel="noopener noreferrer"> گزارشی
فنی</a>
از سوی <a href="https://www.etsi.org/deliver/etsi_tr/103300_103399/103393/01.01.01_60/tr_103393v010101p.pdf" target="_blank" rel="noopener noreferrer">نهاد استانداردهای مخابراتی
اروپا</a>
(ETSI) در سال ۲۰۱۶ و آغاز فرآیند استانداردسازی پروتکلی تحت عنوان
«موقعیت مکانی پیشرفته موبایل» یا به اختصار AML شد. در همان سال،
سیستم‌عامل اندروید سرویس اختصاصی خود با نام Emergency Location Service
را معرفی کرد و در سال ۲۰۱۸ نیز اپل پشتیبانی از این استاندارد را اعلام
نمود.</p>
<p>نحوه عملکرد این سیستم بسیار ساده است: به‌محض شماره‌گیری یک شماره اضطراری
توسط کاربر، موقعیت مکانی وی به‌صورت خودکار توسط گوشی محاسبه شده و از
طریق پیامک به مرکز امداد ارسال می‌شود.  در شکل زیر، نمونه‌ای از نحوه
استقرار اجزای مختلف در پیاده‌سازی این روش نمایش داده شده است.</p>
<div style="text-align:center"><p><img decoding="async" loading="lazy" alt="Example of AML location path to reach a PSAP " src="https://alishir.github.io/assets/images/aml-c9c2f44e6ece683f0a2b815d2fb77d84.svg" class="img_MQSz"></p></div>
<p>طبق
<a href="https://eena.org/blog/webinars/aml-report-card-2023-update/" target="_blank" rel="noopener noreferrer">گزارشی</a>
که سالانه توسط انجمن شماره اضطراری اروپا (EENA) منتشر می‌شود، پیاده‌سازی
و استفاده از این سرویس تاثیر قابل توجهی در افزایش دقت و سرعت پاسخ دهی
داشته است.  به عنوان مثال، در کشور آلمان، دقت تعیین موقعیت مکانی مشترک
بر اساس روش‌های مبتنی بر شبکه چیزی بین یک تا ۲۵ کیلومتر بوده، در حالی
که با استفاده از روش‌های مبتنی بر تلفن همراه این دقت بین ۳ تا ۳۰ متر
بوده است. در شکل زیر این تفاوت به صورت تقریبی نمایش داده شده است.</p>
<div style="text-align:center"><p><img decoding="async" loading="lazy" alt="Cell-ID vs AML accuracy" src="https://alishir.github.io/assets/images/header-0ca473bae6dc825cba016b29ade60958.svg" class="img_MQSz"></p></div>
<p>نکته مهم اینجاست که موقعیت مکانی کاربر تنها در صورت تماس با یکی از
شماره‌های اضطراری به واحدهای امدادی ارسال می‌شود؛ بنابراین دسترسی به
اطلاعات مکانی در سایر مواقع ممکن نیست. همچنین، حتی در شرایط اضطراری،
این داده‌ها صرفاً در اختیار اپراتور یا مرکز امداد قرار می‌گیرند و به هیچ
عنوان برای شرکت‌های ثالث، مانند گوگل، ارسال نمی‌شوند.</p>
<p>فعال‌سازی این سرویس در کشور نیازمند هماهنگی میان نهادهای مرتبط (مانند
اورژانس، آتش نشانی و ...) و اپراتورهای تلفن همراه با شرکت گوگل
است. طبق
<a href="https://developers.google.com/android/els/fundamentals/access" target="_blank" rel="noopener noreferrer">مستندات</a>
گوگل، در گام اول باید فرم درخواست همکاری تکمیل شود و پس از آن مراحل
بعدی آغاز می‌شود. امیدوارم به زودی شاهد فعال‌سازی و بهره‌برداری از این
سرویس در کشور عزیزمان باشیم.</p>]]></content>
        <author>
            <name>علی</name>
            <uri>https://www.linkedin.com/in/ali-shirvani-37a031191/</uri>
        </author>
        <category label="AML" term="AML"/>
        <category label="ETSI" term="ETSI"/>
        <category label="EENA" term="EENA"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[روش کدگذاری TBCD]]></title>
        <id>https://alishir.github.io/telephony-binary-coded-decimal</id>
        <link href="https://alishir.github.io/telephony-binary-coded-decimal"/>
        <updated>2024-12-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[کدگذاری، مشخص کننده ادبیات مشترک برای تعامل اجزاء یک سیستم با یکدیگر]]></summary>
        <content type="html"><![CDATA[<p>کدگذاری، مشخص کننده ادبیات مشترک برای تعامل اجزاء یک سیستم با یکدیگر
است. در صورت عدم کدگذاری صحیح اجزاء یک سیستم نمی‌توانند به درستی با
یکدیگر تعامل کنند. به عنوان نمونه عبارت <code>01/11/06</code>، بسته به <a href="https://en.wikipedia.org/wiki/List_of_date_formats_by_country" target="_blank" rel="noopener noreferrer">روش
کدگذاری</a>
استفاده شده می‌تواند بیانگر تاریخ ۱ نوابر سال ۲۰۰۶ و یا ۱۱ ژانویه سال
۲۰۰۶ باشد. این مثال به خوبی اهمیت موضوع کدگذاری را مشخص می‌کند.</p>
<p>یکی از روش‌های کدگذاری مورد استفاده در شبکه‌های مخابراتی، روش Telephony
Binary-Coded Decimal یا به اختصار TBCD است. این روش برای کدگذاری
مقادیری مانند <code>IMSI</code>، <code>IMEI</code> و برخی آدرس‌ها و شماره‌ها استفاده
می‌شود. مثلا در سند <a href="https://www.3gpp.org/dynareport?code=29338" target="_blank" rel="noopener noreferrer">3GPP TS
29.338</a> به چند نمونه از
آدرس‌هایی که با روش TBCD کدگذاری شده‌اند اشاره شده است.</p>
<p>روش کدگذاری TBCD برای نمایش اعداد بین ۰ تا ۹ و حروف <code>a, b, c,#,*</code>
استفاده می‌شود. برای صرفه‌جویی در فضا، هر دو رقم متوالی در یکی بایت
ذخیره می‌شوند، به عبارت دیگر برای ذخیره هر رقم از چهار بیت استفاده
می‌شود. در صورتی که تعداد ارقام فرد باشد برای پر کردن ۴ بیت باقی‌مانده،
از مقدار <code>1111</code> به عنوان پرکننده یا <code>filler</code> استفاده می‌شود.</p>
<p>اعداد ۰ تا ۹ با مقدار متناظر دودویی آن‌ها در نمایش ۴ بیتی کدگذاری
می‌شوند و از مقادیر زیر برای حروف <code>a, b, c, # ,*</code> استفاده می‌شود.</p>
<table><thead><tr><th style="text-align:center">حرف</th><th style="text-align:center">مقدار دودویی</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">1010</td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">1011</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">1100</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">1101</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">1110</td></tr></tbody></table>
<p>در شکل زیر روش کدگذاری TBCD برای مقدار <code>43211</code> نمایش داده شده. ابتدا
هر رقم را با مقدار دودویی ۴ بیتی متناظر تبدیل می‌کنیم. سپس هر دو رقم را
در یک بایت قرار می‌دهیم، به این صورت که اگر بیت‌های موجود در یک بایت را
از راست به چپ، از ۱ تا ۸ شماره‌گذاری کنیم، بیت‌های شماره ۱ تا ۴ برای
نمایش رقم اول و بیت‌های شماره ۵ تا ۸ برای نمایش رقم دوم تخصیص
می‌یابند. در این مثال با توجه به اینکه تعداد ارقام فرد است، از مقدار
<code>1111</code> به عنوان پرکننده ۴ بیت خالی استفاده می‌شود که در شکل با رنگ قرمز
نمایش داده شده است. در نهایت حاصل کدگذاری مقدار <code>0x3412F1</code> می‌باشد.</p>
<div style="text-align:center"><p><img decoding="async" loading="lazy" alt="TBCD-String Encoding Example" src="https://alishir.github.io/assets/images/example_43211-5e2c6e7e64980a866ed71578a07b0a9a.svg" class="img_MQSz"></p></div>
<p>تصویر زیر توضیحات کدگذاری TBCD است که در سند <a href="https://www.3gpp.org/dynareport?code=29002" target="_blank" rel="noopener noreferrer">3GPP TS
29.002</a> به آن اشاره شده.</p>
<div style="text-align:center"><p><img decoding="async" loading="lazy" alt="TBCD-String Encoding" src="https://alishir.github.io/assets/images/tbcd_encoding-7998f45655a0fd2267426e7c37fb78ab.png" class="img_MQSz"></p></div>]]></content>
        <author>
            <name>علی</name>
            <uri>https://www.linkedin.com/in/ali-shirvani-37a031191/</uri>
        </author>
        <category label="TBCD" term="TBCD"/>
        <category label="کدگذاری" term="کدگذاری"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[ماشین حالت]]></title>
        <id>https://alishir.github.io/state-machine</id>
        <link href="https://alishir.github.io/state-machine"/>
        <updated>2024-10-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[واضع عبارت Structured Concurrency در چند نوشته خود به همروندی]]></summary>
        <content type="html"><![CDATA[<p>واضع عبارت <code>Structured Concurrency</code> در چند نوشته خود به همروندی
ساخت‌یافته به عنوان راه رهایی از ماشین حالت اشاره می‌کند.</p>
<p>امروز <a href="https://aws.amazon.com/blogs/architecture/lets-architect-designing-serverless-solutions/" target="_blank" rel="noopener noreferrer">این
مطلب</a>
و دو ویدئویی که به آن اشاره شده را می‌دیدم. جایی در <a href="https://www.youtube.com/watch?v=qs0U0LdNkV0" target="_blank" rel="noopener noreferrer">این
ویدئو</a> در حین پیاده‌سازی
پروژه <code>serverlesspresso</code> متوجه می‌شوند که گویا در حال پیاده‌سازی یک
ماشین حالت هستند. در نهایت ماشین حالت را به یک سری تابع تبدیل می‌کنند
که بر بستر <code>AWS Lambda</code> قابل اجرا باشد و با استفاده از <code>EventBridge</code>
رخدادهای خارجی را پوشش می‌دهند.  به نظر آمازون با سبد محصولی خود تمام
زیرساخت مورد نیاز برای پیاده‌سازی یک ماشین حالت در حالت مقیاس‌پذیر را
فراهم کرده است.</p>
<p>اما اگر به <a href="https://250bpm.com/blog:71/" target="_blank" rel="noopener noreferrer">نوشته‌های</a> آقای <code>Martin Sústrik</code> در مورد همروندی ساخت‌یافته مراجعه کنیم، ایشان دو مشکل را در
مورد ماشین حالت ذکر می‌کنند، اول اینکه ماشین‌های حالت معمولا بزرگ و
شکننده هستند و دوم اینکه معمولا زبان‌های برنامه نویسی به صورت ذاتی از
آن‌ها پشتیبانی نمی‌کنند.</p>
<p>اما در مورد زبان‌ <code>Erlang</code> قضیه متفاوت است و این زبان به صورت ذاتی
رویکردی برای پیاده‌سازی ماشین حالت دارد که تحت عنوان رفتار <code>gen_statem</code>
شناخته
می‌شود. <a href="https://www.erlang.org/doc/system/design_principles.html#behaviours" target="_blank" rel="noopener noreferrer">رفتارها</a>
در این زبان چیزی شبیه مفهوم <code>Design Pattern</code> هستند. برای آشنایی بیشتر
با ماشین حالت در این زبان <a href="https://www.erlang.org/doc/apps/stdlib/gen_statem" target="_blank" rel="noopener noreferrer">مستندات
اصلی</a> خیلی راهگشا
هستند.</p>]]></content>
        <author>
            <name>علی</name>
            <uri>https://www.linkedin.com/in/ali-shirvani-37a031191/</uri>
        </author>
        <category label="Erlang" term="Erlang"/>
        <category label="Elixir" term="Elixir"/>
        <category label="gen_statem" term="gen_statem"/>
        <category label="AWS Lambda" term="AWS Lambda"/>
        <category label="Structured Concurrency" term="Structured Concurrency"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[ظرائف استفاده از cloud-init]]></title>
        <id>https://alishir.github.io/cloud-init</id>
        <link href="https://alishir.github.io/cloud-init"/>
        <updated>2024-10-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[معمولا برای راه‌اندازی سریع یک ماشین ‌مجازی از دیسک‌های آماده شده برای]]></summary>
        <content type="html"><![CDATA[<p>معمولا برای راه‌اندازی سریع یک ماشین ‌مجازی از دیسک‌های آماده شده برای
زیرساخت ابری یا به اصطلاح cloud-ready images استفاده می‌کنم. مثلا اگر
قرار باشه یه ماشین‌مجازی ubuntu نسخه ۲۲.۰۴ را برای کاری استفاده کنم، از
<a href="https://cloud-images.ubuntu.com/" target="_blank" rel="noopener noreferrer" title="ubuntu cloud-ready image
site">اینجا</a> نسخه سیستم عامل را انتخاب می‌کنم و بعد فایل با پسوند
<code>disk-kvm.img</code> را دانلود می‌کنم.</p>
<p>برای راه‌اندازی ماشین مجازی از طریق <code>cloud-init</code> باید از طریق یک منبعی
برخی از پارامترها برای تنظیمات اولیه ماشین مجازی مشخص شود، مثل پسورد
یا شناسه. نکته مهم اینجاست که مستندات آخرین نسخه <code>cloud-init</code> معمولا
روش ساده و سریع برای تست این موضوع مشخص کرده، مثلا در <a href="https://cloudinit.readthedocs.io/en/latest/tutorial/qemu.html" target="_blank" rel="noopener noreferrer">این
قسمت</a>
از روش <code>IMDS</code> استفاده کردند.</p>
<p>اما نکته اینجاست که نسخه <code>cloud-init</code> نصب شده به صورت پیش‌فرض روی فایل
دانلود شده لزوما آخرین نسخه نیست و احتمالا از روش ذکر شده در آخرین
نسخه مستندات هم پشتیبانی نمی‌کنه. برای همین باید اول نسخه <code>cloud-init</code>
نصب شده را پیدا کنیم و بعد از روش متناسب با همون نسخه استفاده کنیم،
مثلا از روش <code>seed.iso</code> استفاده کنیم که در
<a href="https://cloudinit.readthedocs.io/en/22.1_a/topics/debugging.html#analyze-quickstart-kvm" target="_blank" rel="noopener noreferrer">اینجا</a>
بهش اشاره شده.</p>
<p>خلاصه روش به این صورت هست که شما یک فایل با اسم <code>user-data</code> ایجاد می‌کنید با محتوای زیر:</p>
<div class="language-text codeBlockContainer_ZdXq theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_u2Hv"><pre tabindex="0" class="prism-code language-text codeBlock_sEI0 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_XR9c"><span class="token-line" style="color:#393A34"><span class="token plain">#cloud-config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">password: passw0rd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ssh_authorized_keys:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  - ssh-ed25519 .... ali@dev</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">chpasswd: { expire: False }</span><br></span></code></pre></div></div>
<p>سپس با دستور زیر فایل <code>seed.iso</code> را ایجاد می‌کنید:</p>
<div class="language-bash codeBlockContainer_ZdXq theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_u2Hv"><pre tabindex="0" class="prism-code language-bash codeBlock_sEI0 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_XR9c"><span class="token-line" style="color:#393A34"><span class="token plain">sudo apt update</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sudo apt install -y cloud-image-utils</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cloud-localds seed.img user-data</span><br></span></code></pre></div></div>
<p>و در نهایت ماشین مجازی را به این صورت راه می‌اندازیم:</p>
<div class="language-bash codeBlockContainer_ZdXq theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_u2Hv"><pre tabindex="0" class="prism-code language-bash codeBlock_sEI0 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_XR9c"><span class="token-line" style="color:#393A34"><span class="token plain">qemu-system-amd64 -enable-kvm -m 1G -smp 2 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  -vga std -nic user \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  -drive file=ubuntu.img,if=virtio,format=qcow2 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  -drive file=seed.img,if=virtio,format=raw</span><br></span></code></pre></div></div>
<p>نکته دیگر اینکه در صورتی که از نسخه <code>debian-genericcloud</code> استفاده می‌کنید به دلیل عدم وجود درایورهای دستگاه‌های فیزیکی بر روی این نسخه حتما باید از نسخه‌هایی مانند <code>virtio</code> برای دستگاه‌ها استفاده کنید.</p>
<div class="language-bash codeBlockContainer_ZdXq theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_u2Hv"><pre tabindex="0" class="prism-code language-bash codeBlock_sEI0 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_XR9c"><span class="token-line" style="color:#393A34"><span class="token plain">qemu-system-amd64 -enable-kvm -m 1G -smp 2 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  -vga std -nic user,model=virtio \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  -drive file=debian-genericcloud.img,if=virtio,format=qcow2 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  -drive file=seed.img,if=virtio,format=raw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>]]></content>
        <author>
            <name>علی</name>
            <uri>https://www.linkedin.com/in/ali-shirvani-37a031191/</uri>
        </author>
        <category label="مجازی‌سازی" term="مجازی‌سازی"/>
        <category label="qemu" term="qemu"/>
        <category label="cloud-init" term="cloud-init"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[معماری NFV]]></title>
        <id>https://alishir.github.io/NFV-Architecture</id>
        <link href="https://alishir.github.io/NFV-Architecture"/>
        <updated>2024-10-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[امروز [این]]></summary>
        <content type="html"><![CDATA[<p>امروز <a href="https://www.etsi.org/images/articles/NFV_Architecture.svg" target="_blank" rel="noopener noreferrer" title="NFV
Architecture">این
فایل</a> با فرمت <code>SVG</code> که بیانگر معماری NFV هست دیدم، صرفا برای
ارجاعات بعدی اینجا هم قرارش میدم. جا داره که از آقای <a href="https://www.linkedin.com/in/laurent-vreck-560174/" target="_blank" rel="noopener noreferrer" title="Laurent
Vreck LinkedIn Profile">Laurent
Vreck</a> بابت این فایل کاربردی تشکر کنم. یکی از مزایای
این فایل لینک‌هایی هست که در هر قسمت به مستندات مربوطه قرار داده شده.</p>
<p><img decoding="async" loading="lazy" alt="NFV Architecture" src="https://alishir.github.io/assets/images/NFV_Architecture-dbb8237de9059fa857c08923dda30620.svg" class="img_MQSz"></p>]]></content>
        <author>
            <name>علی</name>
            <uri>https://www.linkedin.com/in/ali-shirvani-37a031191/</uri>
        </author>
        <category label="NFV" term="NFV"/>
        <category label="ETSI" term="ETSI"/>
        <category label="معماری" term="معماری"/>
    </entry>
</feed>